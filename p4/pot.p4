/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** METRICS VARIABLES  *****************************
*************************************************************************/
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_INGRESS_CLONE = 1;
#define IS_I2E_CLONE(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_INGRESS_CLONE)
register<bit<32>> (1) hdr_seq_num_register;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/
typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> length;
    bit<16> checksum;
}

header nshPot_t {
    /*  NSH base header  */
    bit<2>    version; // Version (It must be 0)
    bit<1>    o; // OAM
    bit<1>    u1; // Unsigned
    bit<6>    ttl;
    bit<6>    length; // For th OPoT the value must be 0x6 following the RFC when MD-TYPE 1 is selected
    bit<4>    u2; // Unsigned
    bit<4>    mdType; // With OPoT this values must be setup to MD-Type 1
    bit<8>    nextProtocol; // Next protocol
    /*  NSH Service Path identifier  */
    bit<24>   servicePathIdentifier; // OPoT flow identifier
    bit<8>    serviceIndex; // Position of the packet in the path. This will identify the reamining nodes in the path.
    /* NSH Context Header */
    bit<128> contextHeader;
    // bit<32>   rnd; // Public secret randomly generated by the IngressNode, and passed to all ndoes.
    // bit<64>   cml; // Cumulative value calculated in a node
    // bit<32>   seqNumber; // This need to be a counter
}

header metrics_header_t {
    bit<24>     servicePathIdentifier;
    bit<8>      serviceIndex;
    bit<128>    contextHeader;
    // bit<32>   rnd; // Public secret randomly generated by the IngressNode, and passed to all ndoes.
    // bit<64>   cml; // Cumulative value calculated in a node
    // bit<32>   seqNumber; // This need to be a counter
    bit<8>      dropped;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
    @name("ipv4")
    ipv4_t     ipv4;
    @name("udp")
    udp_t      udp;
    @name("nshPot")
    nshPot_t    nshPot;
    ipv4_t     inner_ipv4;
    udp_t      inner_udp;
    @name("metrics")
    metrics_header_t  metrics;
}


struct metadata {
    bit valid_udp;
    // Metrics fields
    @field_list(0)
    bit<24>     servicePathIdentifier;
    @field_list(0)
    bit<8>      serviceIndex;
    @field_list(0)
    bit<128>    contextHeader;
    // bit<32>   rnd; // Public secret randomly generated by the IngressNode, and passed to all ndoes.
    // bit<64>   cml; // Cumulative value calculated in a node
    // bit<32>   seqNumber; // This need to be a counter
    @field_list(0)
    bit<8>      dropped;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

const bit<16> TYPE_IPV4 = 0x800;
// Constant values IP
const bit<8> TYPE_IPV4_UDP = 0x11;
// Constant values NSH
const bit<16> UDP_NSH_PORT = 0x19e9; // 6633
// Constant values NSH
const bit<8> TYPE_NSH_IPV4 = 0x1;
const bit<4>  MD_TYPE_1 = 0x1;
// Constant values collector
const bit<16> UDP_METRICS_PORT = 0x2000; // 8192

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4 : parse_ipv4;
            default : accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            TYPE_IPV4_UDP: parse_udp;
            default : accept;
        }
    }

    state parse_udp {
        packet.extract(hdr.udp);
        transition select(hdr.udp.dstPort) {
            UDP_NSH_PORT: parse_nsh;
            default : accept;
        }
    }

    state parse_nsh {
        packet.extract(hdr.nshPot);
        transition select(hdr.nshPot.nextProtocol) {
            TYPE_NSH_IPV4: parse_inner_ipv4;
            default : accept;
        }
    }

    state parse_inner_ipv4 {
        packet.extract(hdr.inner_ipv4);
        transition select(hdr.inner_ipv4.protocol) {
            TYPE_IPV4_UDP: parse_inner_udp;
            default : accept;
        }
    }
    state parse_inner_udp {
        packet.extract(hdr.inner_udp);
        transition accept;
    }

}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}

/*************************************************************************
**************  I N G R E S S   POT Processing   *************************
*************************************************************************/
control PoT(inout headers hdr,
                   inout metadata meta,
                   inout standard_metadata_t standard_metadata) {

    // Action to drop packets
    action drop() {
         mark_to_drop(standard_metadata);
     }

    // Action to update TTL of packets
    action update_ttl(){
      hdr.nshPot.ttl = hdr.nshPot.ttl - 1;
      hdr.ipv4.ttl = hdr.ipv4.ttl -1;
      hdr.inner_ipv4.ttl = hdr.inner_ipv4.ttl -1;
    }

    /**
      * @param number inout bit<64> Number from which we want to calculate the modulo prime number
      * @param prime bit<64> Primer number used to generate the random number and the modulo prime operations
      * @param magic_M bit<64> used to calculate the modulo primer number
      * @param magic_a bit used to calculate the modulo primer number
      * @param magic_s bit<5> used to calculate the modulo primer number
    **/
    action compute_prime_module(inout bit<64> number, bit<64> prime, bit<64> magic_M, bit magic_a, bit<5> magic_s){
       bit <64> n = (((number * magic_M) >> 32) +  number * (bit<64>)magic_a) >> magic_s;
       number = number - prime * n;
    }
    /**
      * @param newcml inout bit<64> new CML number obtained after applying operations
      * @param prime bit<64> prime number used to generate the random number and the modulo prime operations
      * @param secretShare bit<64> Secret (first polynomial)
      * @param publicPol bit<64> Public polynomial (second polynomial)
      * @param lpc bit<64> Lragana Polynomial Constant
      * @param magic_M bit<64> used to calculate the modulo primer number
      * @param magic_a bit used to calculate the modulo primer number
      * @param magic_s bit<5> used to calculate the modulo primer number
      * @param rnd bit<64> random value generated to perform operations in each node
      * @param cml bit<64> accumulated value calculated in each node
      * @param ttl bit<64> time to live value of the received packet
    **/
    action calculate_cml(inout bit<64> newCml, bit<64> prime, bit<64> secretShare, bit<64> publicPol, bit<64> lpc, bit<64> magic_M, bit magic_a, bit<5> magic_s, bit<64> rnd, bit<64> cml, bit<64> ttl)
    {
        // Calculate new values
        newCml = ((secretShare + publicPol + rnd + ttl) * lpc + cml);
        // This is equal to newCml % prime
        compute_prime_module(newCml, prime, magic_M,magic_a,magic_s);
    }

    // Action to clone processed packet
    action do_clone() {
        // Transfer values to metadata
        meta.servicePathIdentifier = hdr.nshPot.servicePathIdentifier;
        meta.serviceIndex = hdr.nshPot.serviceIndex;
        // Clone packet and maintain metadata values in the egress
        clone_preserving_field_list(CloneType.I2E, 1, 0);
    }

    /**
      * @param srcAddr macAddr_t Source MAC address for the egress packet
      * @param dstAddr macAddr_t Destination MAC address for the egress packet
      * @param port egressSpec_t Egress port
    **/
    action ipv4_forward(macAddr_t srcAddr, macAddr_t dstAddr, egressSpec_t port) {
        // Update egress port
        standard_metadata.egress_spec = port;
        // Update MAC values
        hdr.ethernet.srcAddr = srcAddr;
        hdr.ethernet.dstAddr = dstAddr;
        
    }

    /**
      * @param prime bit<64> Primer number used to generate the random number and the modulo prime operations
      * @param identifier bit<24> Used to assign the NSH Service Path Identifier
      * @param serviceIndex bit<8> Used to assign the value of the NSH Service Identifier
      * @param secretShare bit<64> Secret (first polynomial)
      * @param publicPol bit<64> Public polynomial (second polynomial)
      * @param lpc bit<64> Lragana Polynomial Constant
      * @param upstreamMask bit<128> used to xor the information
      * @param magic_M bit<64> used to calculate the modulo primer number
      * @param magic_a bit used to calculate the modulo primer number
      * @param magic_s bit<5> used to calculate the modulo primer number
    **/
    action pot_ingress(bit<64> prime, bit<24> identifier, bit<8> serviceIndex, bit<64> secretShare, bit<64> publicPol, bit<64> lpc, bit<128> upstreamMask, bit<64> magic_M, bit magic_a, bit<5> magic_s) {
        
        // Initialize some variables
        bit<32> rnd;
        bit<64> cml = 0;
        bit<32> seqNumber;
        bit<64> newCml=0;

        // Set INNER_IP values
        hdr.inner_ipv4.setValid();
        hdr.inner_ipv4 = hdr.ipv4;

        // If UDP packet received (non OPoT) move the UDP header to inner header
        if (hdr.udp.isValid()) {
            meta.valid_udp = 1;
            hdr.inner_udp = hdr.udp;
        }

        // Set NSH values
        hdr.nshPot.setValid();
        hdr.nshPot.ttl = (bit<6>)serviceIndex;
        hdr.nshPot.length = 0x6;
        hdr.nshPot.mdType = MD_TYPE_1;
        hdr.nshPot.nextProtocol = TYPE_NSH_IPV4;

        // Sequence number configuration
        hdr_seq_num_register.read(seqNumber, 0);
        hdr_seq_num_register.write(0, seqNumber + 1);

        // Set OPoT identifier values
        hdr.nshPot.servicePathIdentifier = identifier;
        hdr.nshPot.serviceIndex = serviceIndex -1;

        // Set UDP values
        hdr.udp.setValid();
        random(hdr.udp.srcPort,49152,65535);
        hdr.udp.dstPort = UDP_NSH_PORT;
        hdr.udp.length = hdr.inner_ipv4.totalLen + 8 + 24;

        // Set IP values
        hdr.ipv4.totalLen = hdr.udp.length + 20;
        hdr.ipv4.protocol = TYPE_IPV4_UDP;

        // Calculate the OPoT Parameters
        random(rnd,1,prime[31:0]);

        // Calculate CML value
        calculate_cml(newCml, prime, secretShare, publicPol, lpc, magic_M, magic_a, magic_s, (bit<64>) rnd, cml, (bit<64>)hdr.ipv4.ttl);

        // Update TTL
        update_ttl();
        
        // Save OPOT Parameters
        bit<128> contextHeader = rnd ++ newCml ++ seqNumber;
        // Save Context Header in metadata
        meta.contextHeader = contextHeader;
        // Enrypt OPOT Parameters
        bit<128> encryptedContextHeader = upstreamMask ^ contextHeader;
        hdr.nshPot.contextHeader = encryptedContextHeader;

    }


    /**
      * @param prime bit<64> Primer number used to generate the random number and the modulo prime operations
      * @param secretShare bit<64> Secret (first polynomial)
      * @param publicPol bit<64> Public polynomial (second polynomial)
      * @param lpc bit<64> Lragana Polynomial Constant
      * @param upstreamMask bit<128> used to xor the information
      * @param downstreamMask bit<128> used to xor the information
      * @param magic_M bit<64> used to calculate the modulo primer number
      * @param magic_a bit used to calculate the modulo primer number
      * @param magic_s bit<5> used to calculate the modulo primer number
    **/
    action pot_forward(bit<64> prime, bit<64> secretShare, bit<64> publicPol, bit<64> lpc, bit<128> upstreamMask, bit<128> downstreamMask, bit<64> magic_M, bit magic_a, bit<5> magic_s) {
        
        // Initialize variables
        bit<64> newCml=0;
        bit<128> contextHeader = hdr.nshPot.contextHeader ^ downstreamMask;

        // Get the OPoT values
        bit<32> rnd = contextHeader[127:96];
        bit<64> cml = contextHeader[95:32];
        bit<32> seqNumber = contextHeader[31:0];

        // Calculate CML value
        calculate_cml(newCml, prime, secretShare, publicPol, lpc, magic_M, magic_a, magic_s, (bit<64>) rnd, cml, (bit<64>)hdr.ipv4.ttl);

        // Update TTL
        update_ttl();

        // Save OPOT Parameters
        hdr.nshPot.serviceIndex = hdr.nshPot.serviceIndex -1;
        contextHeader = rnd ++ newCml ++ seqNumber;
        // Save Context Header in metadata
        meta.contextHeader = contextHeader;
        // Enrypt OPOT Parameters
        bit<128> encryptedContextHeader = upstreamMask ^ contextHeader;
        hdr.nshPot.contextHeader = encryptedContextHeader;


    }

    /**
      * @param prime bit<64> Primer number used to generate the random number and the modulo prime operations
      * @param secretShare bit<64> Secret (first polynomial)
      * @param publicPol bit<64> Public polynomial (second polynomial)
      * @param lpc bit<64> Lragana Polynomial Constant
      * @param downstreamMask bit<128> used to xor the information
      * @param validator_key bit<64> verify that the secret is correct.
      * @param magic_M bit<64> used to calculate the modulo primer number
      * @param magic_a bit used to calculate the modulo primer number
      * @param magic_s bit<5> used to calculate the modulo primer number
    **/
    action pot_egress(bit<64> prime, bit<64> secretShare, bit<64> publicPol, bit<64> lpc, bit<128> downstreamMask,bit<64> validator_key, bit<64> magic_M, bit magic_a, bit<5> magic_s) {
        
        // Initialize variables
        bit<64> newCml=0;
        bit<128> encryptedContextHeader = hdr.nshPot.contextHeader;
        bit<128> contextHeader = hdr.nshPot.contextHeader ^ downstreamMask;

        // Get the OPoT values
        bit<32> rnd = contextHeader[127:96];
        bit<64> cml = contextHeader[95:32];
        bit<32> seqNumber = contextHeader[31:0];

        // Calculate CML value
         calculate_cml(newCml, prime, secretShare, publicPol, lpc, magic_M, magic_a, magic_s, (bit<64>) rnd, cml, (bit<64>)hdr.ipv4.ttl);

         // Calculate sum of RND and Secret value
         bit <64> sum = (bit<64>) rnd + validator_key;
         compute_prime_module(sum, prime, magic_M,magic_a,magic_s);

        // Verify that the received key matches. If not, drop packet
         if(newCml  ==  sum) {
             meta.dropped = 0;
         } else {
             meta.dropped = 1;
         }

        // Update TTL
        update_ttl();
        // Save OPOT Parameters
        hdr.nshPot.serviceIndex = hdr.nshPot.serviceIndex -1;
        contextHeader = rnd ++ newCml ++ seqNumber;

        // Save Context Header in metadata
        meta.contextHeader = contextHeader;

        // Set the outher headers as invalid to forward the IP packet
        hdr.nshPot.setInvalid();
        hdr.udp.setInvalid();
        hdr.ipv4.setInvalid();
    }

    // Table for middle and egress packets
    table t_pot {
        key = {
            hdr.nshPot.servicePathIdentifier: exact;
            hdr.nshPot.serviceIndex: exact;
            hdr.ipv4.dstAddr: exact;
        }

        actions = {
            pot_ingress;
            pot_forward;
            pot_egress;
            drop;
            NoAction;
        }
    }

    // Table for L2 routing
     table routing_table {
        key = {
            hdr.inner_ipv4.dstAddr: lpm;
            standard_metadata.ingress_port: exact;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        default_action = NoAction();
    }

    // Table for cloned packets
    table clone_table {
        key = {
            hdr.inner_ipv4.dstAddr: lpm;
            standard_metadata.ingress_port: exact;
        }
        actions = {
            do_clone;
        }
    }

    apply {
        // Apply OPoT treatment to packet
        t_pot.apply();
        if (meta.valid_udp == 1) {
            meta.valid_udp = 0;
            hdr.udp.setValid();
        }

        // Apply normal L2 forwarding
        routing_table.apply();

        bit<64> sequence_number = (bit<64>)meta.contextHeader[31:0];
        compute_prime_module(sequence_number, 5, 3435973837, 0, 2);
        // Send only if sequence number is multiple of 5 or a packet has been dropped
        if(sequence_number == 0 || meta.dropped == 1){
            clone_table.apply();
        }

        // If drop flag is active, discard packet
        if (meta.dropped == 1) {
          //meta.dropped = 0;
          drop();
        }
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    /**
      * @param srcAddr macAddr_t Source MAC address for the egress packet
      * @param dstAddr macAddr_t Destination MAC address for the egress packet
      * @param port egressSpec_t Egress port
      * @param ipSrcAddr bit<32> Source IP address for the egress packet
      * @param ipDstAddr bit<32> Destination IP address for the egress packet
    **/
    action send_metrics(macAddr_t srcAddr, macAddr_t dstAddr, egressSpec_t port, bit<32> ipSrcAddr, bit<32> ipDstAddr) {
        // Set port to metrics collector
        standard_metadata.egress_spec = port;
        // Set Ethernet addresses
        hdr.ethernet.srcAddr = srcAddr;
        hdr.ethernet.dstAddr = dstAddr;
        // Set IP addresses and protocol
        hdr.ipv4.srcAddr = ipSrcAddr;
        hdr.ipv4.dstAddr = ipDstAddr;
        hdr.ipv4.protocol = TYPE_IPV4_UDP;
        // Set UDP header
        hdr.udp.setValid();
        random(hdr.udp.srcPort,49152,65535);
        hdr.udp.dstPort = UDP_METRICS_PORT;
        hdr.udp.length = 29; //8 bytes UDP header + 21 bytes Metrics Payload
        // Set IP length
        hdr.ipv4.totalLen = hdr.udp.length + 20;
        //Add metrics to the packet
        hdr.metrics.setValid();
        hdr.metrics.servicePathIdentifier = meta.servicePathIdentifier;
        hdr.metrics.serviceIndex = meta.serviceIndex;
        hdr.metrics.contextHeader = meta.contextHeader;
        hdr.metrics.dropped = meta.dropped;
        // Invalid the rest of headers
        hdr.nshPot.setInvalid();
        hdr.inner_ipv4.setInvalid();
        hdr.inner_udp.setInvalid();
        // Truncate the packet to discard the payload of the cloned packets
        truncate(63);
    }

    // Table for sending metrics to collector
    table metrics_table {
        actions = {
            send_metrics;
        }
    }

    apply { 
        // If it is a cloned packet
        // Build it and send it to controller
        if (IS_I2E_CLONE(standard_metadata)) {
                metrics_table.apply();
        }
     }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    update_checksum(
  	    hdr.inner_ipv4.isValid(),
              { hdr.inner_ipv4.version,
  	            hdr.inner_ipv4.ihl,
                hdr.inner_ipv4.diffserv,
                hdr.inner_ipv4.totalLen,
                hdr.inner_ipv4.identification,
                hdr.inner_ipv4.flags,
                hdr.inner_ipv4.fragOffset,
                hdr.inner_ipv4.ttl,
                hdr.inner_ipv4.protocol,
                hdr.inner_ipv4.srcAddr,
                hdr.inner_ipv4.dstAddr },
              hdr.inner_ipv4.hdrChecksum,
              HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.udp);
        packet.emit(hdr.nshPot);
        packet.emit(hdr.inner_ipv4);
        packet.emit(hdr.inner_udp);
        packet.emit(hdr.metrics);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
PoT(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
